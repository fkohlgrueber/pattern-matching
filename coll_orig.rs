impl EarlyLintPass for CollapsibleIf{fn check_expr(&mut self,cx:&EarlyContext<'_>,expr:&ast::Expr){if!in_macro(expr.span){check_if(cx,expr)}}}fn check_if(cx:EarlyContext<'_>,expr:&ast::Expr){match expr.node{ast::ExprKind::If(ref check,ref then,ref else_)=>{if let Some(ref else_)=*else_{check_collapsible_maybe_if_let(cx,else_);}else{check_collapsible_no_if_let(cx,expr,check,then);}},ast::ExprKind::IfLet(_,_,_,Some(ref else_))=>{check_collapsible_maybe_if_let(cx,else_);},_=>(),}}fn check_collapsible_maybe_if_let(cx:&EarlyContext<'_>,else_:&ast::Expr){if_chain!{if let ast::ExprKind::Block(ref block,_)=else_.node;if!block_starts_with_comment(cx,block);if let Some(else_)=expr_block(block);if!in_macro(else_.span);then{match else_.node{ast::ExprKind::If(..)|ast::ExprKind::IfLet(..)=>{}_=>(),}}}}fn check_collapsible_no_if_let(cx:&EarlyContext<'_>,expr:&ast::Expr,check:&ast::Expr,then:&ast::Block){if_chain!{if!block_starts_with_comment(cx,then);if let Some(inner)=expr_block(then);if let ast::ExprKind::If(ref check_inner,ref content,None)=inner.node;then{if expr.span.ctxt()!=inner.span.ctxt(){return;}}}}fn expr_block(block:&ast::Block)->Option<&ast::Expr>{let mut it=block.stmts.iter();if let(Some(stmt),None)=(it.next(),it.next()){match stmt.node{ast::StmtKind::Expr(ref expr)|ast::StmtKind::Semi(ref expr)=>Some(expr),_=>None,}}else{None}}